<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
    <entry key="putRelationVersionJaxbSQL">
        <![CDATA[
            insert into relation_vistory_p${#} (
                id,
                origin_id,
                shard,
                revision,
                valid_from,
                valid_to,
                data_a,
                create_date,
                created_by,
                status,
                approval,
                shift,
                operation_type,
                operation_id,
                major,
                minor
            )
            select
                ?::uuid,
                ?::uuid,
                ?,
                coalesce((select max(prev.revision) + 1 from relation_vistory_p${#} prev where prev.origin_id = ?::uuid), 1),
                ?,
                ?,
                ?,
                ?,
                ?,
                ?::record_status,
                ?::approval_state,
                ?::data_shift,
                ?::operation_type,
                ?,
                ?,
                ?
        ]]>
    </entry>
    <entry key="putRelationVersionProtostuffSQL">
        <![CDATA[
            insert into relation_vistory_p${#} (
                id,
                origin_id,
                shard,
                revision,
                valid_from,
                valid_to,
                data_b,
                create_date,
                created_by,
                status,
                approval,
                shift,
                operation_type,
                operation_id,
                major,
                minor
            )
            select
                ?::uuid,
                ?::uuid,
                ?,
                coalesce((select max(prev.revision) + 1 from relation_vistory_p${#} prev where prev.origin_id = ?::uuid), 1),
                ?,
                ?,
                ?,
                ?,
                ?,
                ?::record_status,
                ?::approval_state,
                ?::data_shift,
                ?::operation_type,
                ?,
                ?,
                ?
        ]]>
    </entry>
    <entry key="insertEtalonRelationSQL">
        <![CDATA[
            insert into relation_etalons_p${#} (shard, id, name, etalon_id_from, etalon_id_to, create_date, created_by, status, approval, reltype, operation_id)
            values (?, ?, ?, ?, ?, ?, ?, ?::record_status, ?::approval_state, ?::relation_type, ?)
        ]]>
    </entry>
    <entry key="insertOriginRelationSQL">
        <![CDATA[
            insert into 
            relation_origins_p${#}(id, etalon_id, initial_owner, shard, name, origin_id_from, origin_id_to, source_system, create_date, created_by, status, enrichment)
            values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?::record_status, ?)
        ]]>
    </entry>
    <entry key="insertToExternalKeySQL">
        <![CDATA[
            insert into relation_to_keys_p${#} (shard, to_id, name, from_id, etalon_id)
            values (?, ?, ?, ?, ?)
        ]]>
    </entry>
    <entry key="insertFromExternalKeySQL">
        <![CDATA[
            insert into relation_from_keys_p${#} (shard, from_id, name, to_id, etalon_id)
            values (?, ?, ?, ?, ?)
        ]]>
    </entry>
    <entry key="insertEtalonRelationStateDraft">
        <![CDATA[
            insert into etalons_relations_draft_states(etalon_id, revision, status, created_by, create_date)
            select ?::uuid, coalesce((select max(prev.revision) + 1 from etalons_relations_draft_states prev where prev.etalon_id = ?::uuid), 1), ?::record_status, ?, ?
        ]]>
    </entry>
    <entry key="cleanupEtalonRelationStateDrafts">
        <![CDATA[
            delete from etalons_relations_draft_states where etalon_id = ?::uuid
        ]]>
    </entry>
    <entry key="loadLastEtalonRelationStateDraftByEtalonIdSQL">
        <![CDATA[
            select id::text, etalon_id::text, revision, status, create_date, created_by
            from etalons_relations_draft_states where etalon_id = ?::uuid
            order by revision desc
            fetch first 1 rows only
        ]]>
    </entry>
    <entry key="loadEtalonRelationsByIdsSQL">
        <![CDATA[
            select
                shard, lsn, id, name, etalon_id_from, etalon_id_to, create_date, created_by, update_date, updated_by, status, approval, reltype, operation_id
            from
                relation_etalons_p${#}
            where
                id in (select unnest(?))
        ]]>
    </entry>
    <entry key="loadRelationVersionsSQL">
        <![CDATA[
            with
            k (keys) as (
                select case when ? then (
                    select (
                        e.shard,
                        e.lsn,
                        e.id,
                        e.name,
                        e.status,
                        e.approval,
                        coalesce((
                            select true
                            from
                                org_unidata_mdm_data.relation_vistory_p${#} v, org_unidata_mdm_data.relation_origins_p${#} o
                            where
                                o.etalon_id = ?::uuid
                            and v.origin_id = o.id
                            and v.approval = 'APPROVED'::org_unidata_mdm_data.approval_state
                            fetch first 1 rows only), false),
                        e.create_date,
                        e.created_by,
                        mark.update_date,
                        mark.updated_by,
                        e.reltype,
                        e.etalon_id_from,
                        e.etalon_id_to,
                        (  select array_agg((
                               o.id,
                               o.initial_owner,
                               o.status,
                               o.enrichment,
                               coalesce((select max(v.revision) from org_unidata_mdm_data.relation_vistory_p${#} v where v.origin_id = o.id), 0),
                               o.source_system,
                               o.create_date,
                               o.created_by,
                               o.update_date,
                               o.updated_by,
                               o.origin_id_from,
                               o.origin_id_to)::org_unidata_mdm_data.relation_origin_key)
                           from
                               org_unidata_mdm_data.relation_origins_p${#} o
                           where
                               o.etalon_id = ?::uuid
                    )::org_unidata_mdm_data.relation_origin_key[])::org_unidata_mdm_data.relation_key
                    from
                        org_unidata_mdm_data.relation_etalons_p${#} e, 
                        lateral (
                            select ts as update_date, usr as updated_by from (
                                      select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_etalons_p${#} where id = ?::uuid
                                union all select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_origins_p${#} where etalon_id = ?::uuid
                                union all select create_date as ts, created_by as usr from (
                                      select v.create_date, v.created_by
                                      from org_unidata_mdm_data.relation_origins_p${#} o, org_unidata_mdm_data.relation_vistory_p${#} v
                                      where
                                          o.etalon_id = ?::uuid
                                      and v.origin_id = o.id
                                      and (v.approval <> 'DECLINED' and v.approval <> 'PENDING')
                                      order by v.create_date desc fetch first 1 rows only ) f
                                ) t order by ts desc nulls last fetch first 1 rows only
                        ) mark
                    where
                        e.id = ?::uuid
                ) else null end
            ),
            l (lud) as (
                select case when ?::varchar is not null then (
                    select max(v.create_date) as lud 
                    from 
                        org_unidata_mdm_data.relation_vistory_p${#} v, org_unidata_mdm_data.relation_origins_p${#} o
                    where 
                        o.etalon_id = ?::uuid
                    and v.origin_id = o.id
                    and v.operation_id = ?::varchar
                ) else null end
            ),
            r (records) as (
                select
                    array_agg((
                        v.id,
                        v.origin_id,
                        v.shard,
                        v.revision,
                        v.valid_from,
                        v.valid_to,
                        v.create_date,
                        v.created_by,
                        v.status,
                        v.approval,
                        v.shift,
                        v.operation_type,
                        v.operation_id,
                        v.data_a,
                        v.data_b,
                        v.major,
                        v.minor)::org_unidata_mdm_data.relation_vistory_data)::org_unidata_mdm_data.relation_vistory_data[]
                from
                    org_unidata_mdm_data.relation_vistory_p${#} v, (
                        select
                            t.origin_id,
                            max(t.revision) as revision
                        from
                            org_unidata_mdm_data.relation_origins_p${#} o, org_unidata_mdm_data.relation_vistory_p${#} t, l
                        where
                            o.etalon_id = ?::uuid
                        and t.origin_id = o.id
                        and t.create_date <= (select case when ?::varchar is null then coalesce(?::timestamptz, 'infinity') else l.lud end)
                        and (coalesce(?::timestamptz, now()) between coalesce(t.valid_from, '-infinity') and coalesce(t.valid_to, 'infinity'))
                        and (t.approval <> 'DECLINED'::approval_state and (t.approval <> 'PENDING'::approval_state or (? or t.created_by = ?)))
                        group by t.origin_id
                    ) as s
                where
                    v.origin_id = s.origin_id
                and v.revision = s.revision
            )
            select (keys, records)::org_unidata_mdm_data.relation_timeline from k, r
            where ?::timestamptz is null or exists(select true from unnest((r).records) test where ?::timestamptz <= (test).create_date limit 1)
        ]]>
    </entry>
    <entry key="loadToIdsByFromAndNameSQL">
        <![CDATA[
            select id, etalon_id_to, status
        ]]>
    </entry>
    <entry key="checkExistByRelNameSQL">
        <![CDATA[
            select coalesce((select true from relation_etalons_p${#} where name = ? fetch first 1 rows only), false)
        ]]>
    </entry>
    <entry key="changeEtalonsStatusBatchSQL">
        <![CDATA[
            with u (id, update_date, updated_by, status) as (
                select * from unnest(?, ?, ?, ?)
            )
            update relation_etalons_p${#}
            set 
                update_date = u.update_date,
                updated_by  = u.updated_by,
                status      = u.status
            from
                u
            where
                relation_etalons_p${#}.id = u.id
        ]]>
    </entry>
    <entry key="changeOriginsStatusBatchSQL">
        <![CDATA[
            with u (id, update_date, updated_by, status) as (
                select * from unnest(?, ?, ?, ?)
            )
            update relation_origins_p${#}
            set 
                update_date = u.update_date,
                updated_by  = u.updated_by,
                status      = u.status
            from
                u
            where 
                relation_origins_p${#}.shard = ?
            and relation_origins_p${#}.id = u.id
        ]]>
    </entry>
    <entry key="updateOriginRelationSQL">
        <![CDATA[
            update relation_origins_p${#} set update_date = ?, updated_by = ?, status = ?::record_status where shard = ? and id = ?
        ]]>
    </entry>
    <entry key="updateEtalonRelationSQL">
        <![CDATA[
            update relation_etalons_p${#} 
            set update_date = ?, updated_by = ?, status = ?::record_status, approval = ?::approval_state, operation_id = ? where shard = ? and id = ?
        ]]>
    </entry>
    <entry key="deactivateRelationByNameSQL">
        <![CDATA[
            update relation_etalons set update_date = ?, status = ?::record_status where name = ?
        ]]>
    </entry>
    <entry key="changeEtalonApprovalSQL">
        <![CDATA[
            update relation_etalons_p${#} 
            set
                update_date = current_timestamp,
                updated_by = ?,
                approval = ?::approval_state
            where
                id in (select unnest(?))
        ]]>
    </entry>
    <entry key="remapToEtalonRelationSQL">
        <![CDATA[
            with u (id, etalon_id_to, update_date, updated_by, operation_id) as (
                select * from unnest(?, ?, ?, ?, ?)
            )
            update relation_etalons_p${#}
            set 
                etalon_id_to = u.etalon_id_to,
                update_date  = u.update_date,
                updated_by   = u.updated_by,
                operation_id = u.operation_id
            from 
                u
            where 
                relation_etalons_p${#}.id = u.id
        ]]>
    </entry>
    <entry key="remapFromEtalonRelationSQL">
        <![CDATA[
            with u (id, etalon_id_from, update_date, updated_by, operation_id) as (
                select * from unnest(?, ?, ?, ?, ?)
            )
            update relation_etalons_p${#}
            set 
                etalon_id_from  = u.etalon_id_from,
                update_date     = u.update_date,
                updated_by      = u.updated_by,
                operation_id    = u.operation_id
            from 
                u
            where 
                relation_etalons_p${#}.id = u.id
        ]]>
    </entry>
    <entry key="remapOriginRelationSQL">
        <![CDATA[
            with u (id, etalon_id, shard, update_date, updated_by) as (
                select * from unnest(?, ?, ?, ?, ?)
            )
            update relation_origins
            set 
                etalon_id   = u.etalon_id,
                shard       = u.shard,
                update_date = u.update_date,
                updated_by  = u.updated_by
            from 
                u
            where
                relation_origins.shard = ? 
            and relation_origins.id = u.id
        ]]>
    </entry>
    <entry key="remapVistoryRecordsSQL">
        <![CDATA[
            with u (origin_id, new_shard) as (
                select * from unnest(?, ?)
            )
            update relation_vistory
            set 
                shard = u.new_shard
            from
                u
            where
                relation_vistory.shard = ?
            and relation_vistory.origin_id = u.origin_id
        ]]>
    </entry>
    <entry key="cutVistoryByOriginIdSQL">
        <![CDATA[
            delete from relation_vistory_p${#} where origin_id in (select unnest(?))
            returning id, origin_id, shard, revision, valid_from, valid_to, data_a, data_b, create_date, created_by, status, approval, shift, operation_type, operation_id, major, minor
        ]]>
    </entry>
    <entry key="deleteVistoryByOriginIdSQL">
        <![CDATA[
            delete from relation_vistory_p${#} where origin_id in (select unnest(?))
        ]]>
    </entry>
    <entry key="deleteOriginByIdSQL">
        <![CDATA[
            delete from relation_origins_p${#} where shard = ? and id in (select unnest(?))
        ]]>
    </entry>
    <entry key="deleteEtalonByIdSQL">
        <![CDATA[
            delete from relation_etalons_p${#} where id in (select unnest(?))
        ]]>
    </entry>
    <entry key="deleteFromExtIdsSQL">
        <![CDATA[
            with ids (from_id, name, to_id) as (
                select * from unnest(?, ?, ?)
            )
            delete from relation_from_keys_p${#} 
            using 
                ids 
            where 
                relation_from_keys_p${#}.shard = ? 
            and relation_from_keys_p${#}.from_id = ids.from_id 
            and relation_from_keys_p${#}.name = ids.name 
            and relation_from_keys_p${#}.to_id = ids.to_id
        ]]>
    </entry>
    <entry key="deleteToExtIdsSQL">
        <![CDATA[
            with ids (to_id, name, from_id) as (
                select * from unnest(?, ?, ?)
            )
            delete from relation_to_keys_p${#} 
            using 
                ids 
            where 
                relation_to_keys_p${#}.shard = ? 
            and relation_to_keys_p${#}.to_id = ids.to_id 
            and relation_to_keys_p${#}.name = ids.name 
            and relation_to_keys_p${#}.from_id = ids.from_id
        ]]>
    </entry>
    <entry key="updatePendingVersionsSQL">
        <![CDATA[
            update relation_vistory_p${#}
            set approval = ?::approval_state
            from
                relation_vistory_p${#} v,
                relation_origins_p${#} o,
                relation_etalons_p${#} e
            where
                e.id = ?::uuid
            and o.etalon_id = e.id
            and v.origin_id = o.id
            and v.approval = 'PENDING'
            and relation_vistory_p${#}.id = v.id
        ]]>
    </entry>
    <!-- Keys -->
    <entry key="loadSysKeyByFromToAndNameSQL">
        <![CDATA[
            select etalon_id from org_unidata_mdm_data.relation_from_keys_p${#} 
            where (shard = ? and from_id = ? and name = ? and to_id = ?) 
        ]]>
    </entry>
    <entry key="loadSysKeyByFromAndNamesSQL">
        <![CDATA[
            select etalon_id from org_unidata_mdm_data.relation_from_keys_p${#} 
            where (shard = ? and from_id = ? and name in (select unnest(?))) 
        ]]>
    </entry>
    <entry key="loadSysKeyByFromSQL">
        <![CDATA[
            select etalon_id from org_unidata_mdm_data.relation_from_keys_p${#} 
            where (shard = ? and from_id = ?) 
        ]]>
    </entry>
    <entry key="loadSysKeyByToAndNamesSQL">
        <![CDATA[
            select etalon_id from org_unidata_mdm_data.relation_to_keys_p${#} 
            where (shard = ? and to_id = ? and name in (select unnest(?))) 
        ]]>
    </entry>
    <entry key="loadSysKeyByToSQL">
        <![CDATA[
            select etalon_id from org_unidata_mdm_data.relation_to_keys_p${#} 
            where (shard = ? and to_id = ?)
        ]]>
    </entry>
    <entry key="loadKeysByLSNSQL">
        <![CDATA[
            select (
                e.shard,
                e.lsn,
                e.id, 
                e.name,
                e.status, 
                e.approval,
                coalesce((select true 
                    from 
                        org_unidata_mdm_data.relation_vistory_p${#} v, org_unidata_mdm_data.relation_origins_p${#} o
                    where 
                        o.etalon_id = e.id
                    and v.origin_id = o.id 
                    and v.approval = 'APPROVED'::org_unidata_mdm_data.approval_state
                    fetch first 1 rows only), false), 
                e.create_date, 
                e.created_by, 
                m.update_date, 
                m.updated_by,
                e.reltype,
                e.etalon_id_from,
                e.etalon_id_to,
                (   select array_agg((
                        o.id,
                        o.initial_owner,
                        o.status,
                        o.enrichment,
                        coalesce((select max(v.revision) from org_unidata_mdm_data.relation_vistory_p${#} v where v.origin_id = o.id), 0),
                        o.source_system,
                        o.create_date,
                        o.created_by,
                        o.update_date,
                        o.updated_by,
                        o.origin_id_from,
                        o.origin_id_to)::org_unidata_mdm_data.relation_origin_key)
                    from 
                        org_unidata_mdm_data.relation_origins_p${#} o 
                    where 
                        o.etalon_id = e.id)::org_unidata_mdm_data.relation_origin_key[]
            )::org_unidata_mdm_data.relation_key
            from
                org_unidata_mdm_data.relation_etalons_p${#} e, 
            lateral (
                select ts as update_date, usr as updated_by from (
                        select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_etalons_p${#} where id = e.id
                    union all select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_origins_p${#} where etalon_id = e.id
                    union all select create_date as ts, created_by as usr from (
                        select v.create_date, v.created_by 
                        from org_unidata_mdm_data.relation_origins_p${#} o, org_unidata_mdm_data.relation_vistory_p${#} v 
                        where 
                            o.etalon_id = e.id
                        and v.origin_id = o.id 
                        and (v.approval <> 'DECLINED' and v.approval <> 'PENDING')
                        order by v.create_date desc fetch first 1 rows only ) f
                ) t order by ts desc nulls last fetch first 1 rows only
            ) m
            where
                e.shard = ?
            and e.lsn = ?
        ]]>
    </entry>
    <entry key="loadKeysByEtalonIdSQL">
        <![CDATA[
            select (
                e.shard,
                e.lsn,
                e.id, 
                e.name,
                e.status, 
                e.approval,
                coalesce((select true 
                    from 
                        org_unidata_mdm_data.relation_vistory_p${#} v, org_unidata_mdm_data.relation_origins_p${#} o
                    where 
                        o.etalon_id = e.id
                    and v.origin_id = o.id 
                    and v.approval = 'APPROVED'::org_unidata_mdm_data.approval_state
                    fetch first 1 rows only), false), 
                e.create_date, 
                e.created_by, 
                m.update_date, 
                m.updated_by,
                e.reltype,
                e.etalon_id_from,
                e.etalon_id_to,
                (   select array_agg((
                        o.id,
                        o.initial_owner,
                        o.status,
                        o.enrichment,
                        coalesce((select max(v.revision) from org_unidata_mdm_data.relation_vistory_p${#} v where v.origin_id = o.id), 0),
                        o.source_system,
                        o.create_date,
                        o.created_by,
                        o.update_date,
                        o.updated_by,
                        o.origin_id_from,
                        o.origin_id_to)::org_unidata_mdm_data.relation_origin_key)
                    from 
                        org_unidata_mdm_data.relation_origins_p${#} o 
                    where 
                        o.etalon_id = e.id)::org_unidata_mdm_data.relation_origin_key[]
            )::org_unidata_mdm_data.relation_key
            from
                org_unidata_mdm_data.relation_etalons_p${#} e, 
            lateral (
                select ts as update_date, usr as updated_by from (
                        select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_etalons_p${#} where id = e.id
                    union all select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_origins_p${#} where etalon_id = e.id
                    union all select create_date as ts, created_by as usr from (
                        select v.create_date, v.created_by 
                        from org_unidata_mdm_data.relation_origins_p${#} o, org_unidata_mdm_data.relation_vistory_p${#} v 
                        where
                            o.etalon_id = e.id
                        and v.origin_id = o.id 
                        and (v.approval <> 'DECLINED' and v.approval <> 'PENDING')
                        order by v.create_date desc fetch first 1 rows only ) f
                ) t order by ts desc nulls last fetch first 1 rows only
            ) m
            where
                e.id = ?
        ]]>
    </entry>
    <!-- END OF Keys -->
    <!-- Timeline -->
    <!-- 1. TL by relation etalon id -->
    <entry key="loadTimelineByEtalonIdSQL">
        <![CDATA[
            with recursive t (id, origin_id, valid_from, valid_to, revision, status, approval, last_update) as (
            select v.id, v.origin_id, v.valid_from, v.valid_to, v.revision, v.status, v.approval, v.create_date
            from org_unidata_mdm_data.relation_vistory_p${#} v,
                ( select  i.origin_id, max(i.revision) as revision
                  from org_unidata_mdm_data.relation_origins_p${#} o, org_unidata_mdm_data.relation_vistory_p${#} i, org_unidata_mdm_data.relation_etalons_p${#} e
                  where
                  -- Cut off containments from the beginning
                      e.id = ?::uuid
                  and e.reltype <> 'CONTAINS'::relation_type  
                  and o.etalon_id = e.id
                  and i.origin_id = o.id
                  and i.status <> 'MERGED'
                  and (i.approval <> 'DECLINED' and (i.approval <> 'PENDING' or (? or i.created_by = ?)))
                  group by i.origin_id ) as s
            where v.origin_id = s.origin_id
            and v.revision = s.revision
            union all
            select v.id, v.origin_id, v.valid_from, v.valid_to, v.revision, v.status, v.approval, v.create_date
            from org_unidata_mdm_data.relation_vistory_p${#} v, t tt
            where
                v.origin_id = tt.origin_id
            and v.revision =
                ( select max(i.revision) as revision from org_unidata_mdm_data.relation_vistory_p${#} i
                  where
                      i.origin_id = tt.origin_id
                  and (coalesce(i.valid_from, '-infinity') < coalesce(tt.valid_from, '-infinity')
                    or coalesce(i.valid_to, 'infinity') > coalesce(tt.valid_to, 'infinity'))
                  and i.revision < tt.revision
                  and i.status <> 'MERGED'
                  and (i.approval <> 'DECLINED' and (i.approval <> 'PENDING' or (? or i.created_by = ?))) )
            )
            select (
                case when ? then (
                    select (
                        ek.shard,
                        ek.lsn,
                        ek.id,
                        ek.name,
                        ek.status,
                        ek.approval,
                        coalesce((select true 
                            from 
                                org_unidata_mdm_data.relation_vistory_p${#} v, org_unidata_mdm_data.relation_origins_p${#} o
                            where 
                                o.etalon_id = ek.id
                            and v.origin_id = o.id 
                            and v.approval = 'APPROVED'::org_unidata_mdm_data.approval_state
                            fetch first 1 rows only), false),
                        ek.create_date,
                        ek.created_by,
                        mark.update_date,
                        mark.updated_by,
                        ek.reltype,
                        ek.etalon_id_from,
                        ek.etalon_id_to,
                        (  select array_agg((
                               o.id,
                               o.initial_owner,
                               o.status,
                               o.enrichment,
                               coalesce((select max(v.revision) from org_unidata_mdm_data.relation_vistory_p${#} v where v.origin_id = o.id), 0),
                               o.source_system,
                               o.create_date,
                               o.created_by,
                               o.update_date,
                               o.updated_by,
                               o.origin_id_from,
                               o.origin_id_to)::org_unidata_mdm_data.relation_origin_key)
                           from
                               org_unidata_mdm_data.relation_origins_p${#} o
                           where
                               o.etalon_id = ek.id
                    )::org_unidata_mdm_data.relation_origin_key[])::org_unidata_mdm_data.relation_key
                    from
                        org_unidata_mdm_data.relation_etalons_p${#} ek, 
                        lateral (
                            select ts as update_date, usr as updated_by from (
                                      select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_etalons_p${#} where id = ek.id
                                union all select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_origins_p${#} where etalon_id = ek.id
                                union all select create_date as ts, created_by as usr from (
                                      select v.create_date, v.created_by
                                      from org_unidata_mdm_data.relation_origins_p${#} o, org_unidata_mdm_data.relation_vistory_p${#} v
                                      where
                                          o.etalon_id = ek.id
                                      and v.origin_id = o.id
                                      and (v.approval <> 'DECLINED' and v.approval <> 'PENDING')
                                      order by v.create_date desc fetch first 1 rows only ) f
                            ) t order by ts desc nulls last fetch first 1 rows only
                        ) mark
                    where
                        ek.id = e.id
                ) else null end,
                ( select array_agg((
                        v.id,
                        v.origin_id,
                        v.shard,
                        v.revision,
                        v.valid_from,
                        v.valid_to,
                        v.create_date,
                        v.created_by,
                        v.status,
                        v.approval,
                        v.shift,
                        v.operation_type,
                        v.operation_id,
                        case when ? then v.data_a else null end,
                        case when ? then v.data_b else null end,
                        v.major,
                        v.minor )::org_unidata_mdm_data.relation_vistory_data )::org_unidata_mdm_data.relation_vistory_data[]
                  from t, org_unidata_mdm_data.relation_vistory_p${#} v
                  where
                      v.id = t.id
                  and v.shard = ?
                  and not exists (  
                      select true from t tt
                      where t.origin_id = tt.origin_id
                      and t.revision < tt.revision
                      and (
                          coalesce(t.valid_from, '-infinity') between coalesce(tt.valid_from, '-infinity') and coalesce(tt.valid_to, 'infinity')
                          and coalesce(t.valid_to, 'infinity') between coalesce(tt.valid_from, '-infinity') and coalesce(tt.valid_to, 'infinity')
                      )
                   )
                )
            )::org_unidata_mdm_data.relation_timeline
            from org_unidata_mdm_data.relation_etalons_p${#} e
            where 
                e.id = ?
        ]]>
    </entry>
    <!-- 1. TL by relation LSN -->
    <entry key="loadTimelineByLSNSQL">
        <![CDATA[
            with recursive t (id, origin_id, valid_from, valid_to, revision, status, approval, last_update) as (
            select v.id, v.origin_id, v.valid_from, v.valid_to, v.revision, v.status, v.approval, v.create_date
            from org_unidata_mdm_data.relation_vistory_p${#} v,
                ( select i.origin_id, max(i.revision) as revision
                  from org_unidata_mdm_data.relation_origins_p${#} o, org_unidata_mdm_data.relation_vistory_p${#} i, org_unidata_mdm_data.relation_etalons_p${#} e
                  where
                  -- Cut off containments from the beginning
                      e.shard = ?
                  and e.lsn = ?
                  and e.reltype <> 'CONTAINS'::relation_type  
                  and o.etalon_id = e.id
                  and i.origin_id = o.id
                  and i.status <> 'MERGED'
                  and (i.approval <> 'DECLINED' and (i.approval <> 'PENDING' or (? or i.created_by = ?)))
                  group by i.origin_id ) as s
            where v.origin_id = s.origin_id
            and v.revision = s.revision
            --------------------- Recursive sub select without duplicates
            union all
            select v.id, v.origin_id, v.valid_from, v.valid_to, v.revision, v.status, v.approval, v.create_date
            from org_unidata_mdm_data.relation_vistory_p${#} v, t tt
            where
                v.origin_id = tt.origin_id
            and v.revision =
                ( select max(i.revision) as revision from org_unidata_mdm_data.relation_vistory_p${#} i
                  where
                      i.origin_id = tt.origin_id
                  and (coalesce(i.valid_from, '-infinity') < coalesce(tt.valid_from, '-infinity')
                    or coalesce(i.valid_to, 'infinity') > coalesce(tt.valid_to, 'infinity'))
                  and i.revision < tt.revision
                  and i.status <> 'MERGED'
                  and (i.approval <> 'DECLINED' and (i.approval <> 'PENDING' or (? or i.created_by = ?))) )
            )
            select (
                case when ? then (
                    select (
                        ek.shard,
                        ek.lsn,
                        ek.id,
                        ek.name,
                        ek.status,
                        ek.approval,
                        coalesce((select true 
                            from 
                                org_unidata_mdm_data.relation_vistory_p${#} v, org_unidata_mdm_data.relation_origins_p${#} o
                            where 
                                o.etalon_id = ek.id
                            and v.origin_id = o.id 
                            and v.approval = 'APPROVED'::org_unidata_mdm_data.approval_state
                            fetch first 1 rows only), false),
                        ek.create_date,
                        ek.created_by,
                        mark.update_date,
                        mark.updated_by,
                        ek.reltype,
                        ek.etalon_id_from,
                        ek.etalon_id_to,
                        (  select array_agg((
                               o.id,
                               o.initial_owner,
                               o.status,
                               o.enrichment,
                               coalesce((select max(v.revision) from org_unidata_mdm_data.relation_vistory_p${#} v where v.origin_id = o.id), 0),
                               o.source_system,
                               o.create_date,
                               o.created_by,
                               o.update_date,
                               o.updated_by,
                               o.origin_id_from,
                               o.origin_id_to)::org_unidata_mdm_data.relation_origin_key)
                           from
                               org_unidata_mdm_data.relation_origins_p${#} o
                           where
                               o.etalon_id = ek.id
                    )::org_unidata_mdm_data.relation_origin_key[])::org_unidata_mdm_data.relation_key
                    from
                        org_unidata_mdm_data.relation_etalons_p${#} ek, 
                        lateral (
                            select ts as update_date, usr as updated_by from (
                                      select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_etalons_p${#} where id = ek.id
                                union all select update_date as ts, updated_by as usr from org_unidata_mdm_data.relation_origins_p${#} where etalon_id = ek.id
                                union all select create_date as ts, created_by as usr from (
                                      select v.create_date, v.created_by
                                      from org_unidata_mdm_data.relation_origins_p${#} o, org_unidata_mdm_data.relation_vistory_p${#} v
                                      where
                                          o.etalon_id = ek.id
                                      and v.origin_id = o.id
                                      and (v.approval <> 'DECLINED' and v.approval <> 'PENDING')
                                      order by v.create_date desc fetch first 1 rows only ) f
                                ) t order by ts desc nulls last fetch first 1 rows only
                        ) mark
                    where
                        ek.id = e.id
                ) else null end,
                ( select array_agg((
                        v.id,
                        v.origin_id,
                        v.shard,
                        v.revision,
                        v.valid_from,
                        v.valid_to,
                        v.create_date,
                        v.created_by,
                        v.status,
                        v.approval,
                        v.shift,
                        v.operation_type,
                        v.operation_id,
                        case when ? then v.data_a else null end,
                        case when ? then v.data_b else null end,
                        v.major,
                        v.minor )::org_unidata_mdm_data.relation_vistory_data )::org_unidata_mdm_data.relation_vistory_data[]
                  from t, org_unidata_mdm_data.relation_vistory_p${#} v
                  where
                      v.id = t.id
                  and v.shard = ?
                  and not exists (  
                      select true from t tt
                      where t.origin_id = tt.origin_id
                      and t.revision < tt.revision
                      and (
                          coalesce(t.valid_from, '-infinity') between coalesce(tt.valid_from, '-infinity') and coalesce(tt.valid_to, 'infinity')
                          and coalesce(t.valid_to, 'infinity') between coalesce(tt.valid_from, '-infinity') and coalesce(tt.valid_to, 'infinity')
                      )
                   )
                )
            )::org_unidata_mdm_data.relation_timeline
            from org_unidata_mdm_data.relation_etalons_p${#} e
            where 
                e.shard = ?
            and e.lsn = ?
        ]]>
    </entry>
    <!-- END OF Timeline -->
</properties>